<!DOCTYPE html>
<html lang="en">
<head>
	<title>Test ExtrudeGeometry</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="./main.css">
	<style>
		#info > * {
			max-width: 650px;
			margin-left: auto;
			margin-right: auto;
		}
	</style>
</head>
<body>

<div id="container"></div>

<script type="module">

	import * as THREE from '../build/three.module.js';

	import {OrbitControls} from './jsm/controls/OrbitControls.js';

	var scene, camera, controls, pointLight, stats;
	var renderer, mixer;

	var clock = new THREE.Clock();
	var container = document.getElementById('container');

	renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.toneMapping = THREE.ReinhardToneMapping;
	container.appendChild(renderer.domElement);

	scene = new THREE.Scene();

	const axesHelper = new THREE.AxesHelper(500);
	scene.add(axesHelper);

	camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
	camera.position.set(49.28181283403017, 63.93385829379924, 65.34484039897056);
	window.camera = camera;
	scene.add(camera);

	controls = new OrbitControls(camera, renderer.domElement);
	controls.maxPolarAngle = Math.PI * 0.5;

	scene.add(new THREE.AmbientLight(0x404040));

	pointLight = new THREE.PointLight(0xffffff, 1);
	camera.add(pointLight);


	const length = 20, width = 20;

	const shape = new THREE.Shape();
	shape.moveTo(0, 0);
	shape.lineTo(0, width);
	shape.lineTo(length, width);
	shape.lineTo(length, 0);
	shape.lineTo(0, 0);

	const extrudeSettings = {
		depth: 10,
		bevelEnabled: false
	};

	const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

	let faces = geometry.faces;
	let facesLen = faces.length;
	for (let i = 0; i < facesLen; i++) {
		let va = geometry.vertices[faces[i].a];
		let vb = geometry.vertices[faces[i].b];
		let vc = geometry.vertices[faces[i].c];

		geometry.faceVertexUvs[0][i][0].x = va.x / width;
		geometry.faceVertexUvs[0][i][0].y = va.y / length;
		geometry.faceVertexUvs[0][i][1].x = vb.x / width;
		geometry.faceVertexUvs[0][i][1].y = vb.y / length;
		geometry.faceVertexUvs[0][i][2].x = vc.x / width;
		geometry.faceVertexUvs[0][i][2].y = vc.y / length;
	}
	geometry.computeBoundingSphere();

	const material = new THREE.MeshLambertMaterial({color: 0xffffff});

	// instantiate a loader
	const loader = new THREE.TextureLoader();
	loader.load('./textures/758px-Canestra_di_frutta_(Caravaggio).jpg', function (texture) {
				material.map = texture;
				material.needsUpdate = true;
			},
			undefined,
			function (err) {
				console.error('An error happened.');
			}
	);

	const mesh = new THREE.Mesh(geometry, material);
	scene.add(mesh);

	window.onresize = function () {

		var width = window.innerWidth;
		var height = window.innerHeight;

		camera.aspect = width / height;
		camera.updateProjectionMatrix();

		renderer.setSize(width, height);

	};


	animate();

	function animate() {

		requestAnimationFrame(animate);

		renderer.render(scene, camera);

	}

</script>

</body>

</html>
