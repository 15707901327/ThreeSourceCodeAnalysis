<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>dynamic noise - color mapping</title>
  <style>
    * {
      padding: 0;
      margin: 0;
    }

    #app {
      position: absolute;
      left: 0;
      right: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
  </style>
</head>
<body>
<div id="app"></div>
<script type="module">

  import * as THREE from "../../build/three_r109.module.js";
  import {OrbitControls} from "../jsm/controls/OrbitControls_slr107.js"

  const ColorMapShader = {
    uniforms: {
      "scale": {value: new THREE.Vector2(1, 1)},
      "offset": {value: new THREE.Vector2(0, 0)},
      "time": {value: 1.0},
    },
    vertexShader: `
        varying vec2 vUv;
        uniform vec2 scale;
        uniform vec2 offset;

        void main( void ) {
            vUv = uv * scale + offset;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    `,
    fragmentShader: `
        varying vec2 vUv;
        uniform float time;
        // 梯度向量生成 输入网格顶点位置，输出随机向量
        vec3 random_perlin( vec3 p ) {
            p = vec3(
                    dot(p,vec3(127.1,311.7,69.5)),
                    dot(p,vec3(269.5,183.3,132.7)), 
                    dot(p,vec3(247.3,108.5,96.5)) 
                    );
            return -1.0 + 2.0*fract(sin(p)*43758.5453123);
        }
        // 梯度噪声 (Gradient Noise)
        float noise_perlin (vec3 st) {
            // 获取当前网格索引
            vec3 i = floor(st);
            // 获取当前片元在网格内的相对位置
            vec3 s = fract(st);

            // 计算梯度贡献值
            float a = dot(random_perlin(i),s);// 梯度向量与距离向量点积运算
            float b = dot(random_perlin(i + vec3(1, 0, 0)),s - vec3(1, 0, 0));
            float c = dot(random_perlin(i + vec3(0, 1, 0)),s - vec3(0, 1, 0));
            float d = dot(random_perlin(i + vec3(0, 0, 1)),s - vec3(0, 0, 1));
            float e = dot(random_perlin(i + vec3(1, 1, 0)),s - vec3(1, 1, 0));
            float f = dot(random_perlin(i + vec3(1, 0, 1)),s - vec3(1, 0, 1));
            float g = dot(random_perlin(i + vec3(0, 1, 1)),s - vec3(0, 1, 1));
            float h = dot(random_perlin(i + vec3(1, 1, 1)),s - vec3(1, 1, 1));

            // 平滑插值
            vec3 u = smoothstep(0.,1.,s);

            // 叠加四个梯度贡献值
            return mix(mix(mix( a, b, u.x),
                        mix( c, e, u.x), u.y),
                    mix(mix( d, f, u.x),
                        mix( g, h, u.x), u.y), u.z);
        }
        // 噪声湍流
        float noise_turbulence(vec3 p)
        {
            float f = 0.0;
            float a = 1.;
            // 网格生成
            p = 4.0 * p;
            for (int i = 0; i < 5; i++) {
                f += a * abs(noise_perlin(p));
                p = 2.0 * p;
                a /= 2.;
            }
            return f;
        }
        void main( void ) {
            float c1 = noise_turbulence(vec3(vUv, time/10.0));
            vec3 color = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);
            gl_FragColor = vec4( color, 1.0 );
        }
    `
  };

  class App{
    constructor(container = document.body, fov = 70, far = 5000) {
      if (!(container instanceof HTMLElement)) {
        throw new Error('container is not a HTMLElement!');
      }

      // Initialize the scene
      const scene = new THREE.Scene();

      // Initialize the camera
      const camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, far);
      camera.position.set(-120, 80, 20);
      scene.add(camera);

      // Initialize the renderer
      const renderer = new THREE.WebGLRenderer({antialias: true});
      container.appendChild(renderer.domElement);

      this.scene = scene;
      this.camera = camera;
      this.renderer = renderer;
      this.clock = new THREE.Clock();

      this._initRender();
      this.start();
    }

    _initRender() {
      const {scene, camera, renderer, clock} = this;
      renderer.setSize(window.innerWidth, window.innerHeight);
      // renderer.shadowMap.enabled = true;
      renderer.setPixelRatio(window.devicePixelRatio);
      window.addEventListener('resize', e => {
        // justify the renderer when resize the window
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }, false);
      new OrbitControls(camera, renderer.domElement);
      renderer.setAnimationLoop(() => {
        const delta = clock.getDelta();
        this.update(delta);
        renderer.setRenderTarget(null);
        renderer.render(scene, camera);
      });
    }

    start() {
      this.addLight();
      this.addBall();
    }

    update(delta) {
      this.uniformsNoise['time'].value += delta;
      this._renderNoise();
    }

    initNoise() {
      const {scene, renderer} = this;

      const cameraOrtho = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -10000, 10000);

      const colorMapMaterial = new THREE.ShaderMaterial({
        ...ColorMapShader,
        uniforms: {
          ...ColorMapShader.uniforms,
          scale: {value: new THREE.Vector2(1, 1)}
        },
        lights: false
      });
      const plane = new THREE.PlaneBufferGeometry(window.innerWidth, window.innerHeight);
      const noise = new THREE.Mesh(plane, colorMapMaterial);
      scene.add(noise);

      const colorMap = new THREE.WebGLRenderTarget(512, 512);
      colorMap.texture.generateMipmaps = false;
      colorMap.texture.wrapS = colorMap.texture.wrapT = THREE.RepeatWrapping;

      this.noise = noise;
      this.colorMap = colorMap;
      this.uniformsNoise = colorMapMaterial.uniforms;
      this.cameraOrtho = cameraOrtho;
      this._renderNoise();
    }

    _renderNoise() {
      // 解构获取对应的变量值
      const {scene, noise, colorMap, renderer, cameraOrtho} = this;
      noise.visible = true;
      renderer.setRenderTarget(colorMap);
      renderer.clear();
      renderer.render(scene, cameraOrtho);
      noise.visible = false;
    }

    addLight() {
      const {scene} = this;
      scene.add(new THREE.AmbientLight(0xcccccc));

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.08);
      directionalLight.position.set(500, 2000, 0);
      scene.add(directionalLight);
    }

    addBall() {
      const {scene} = this;
      this.initNoise();
      // create a ball
      const geometry = new THREE.SphereBufferGeometry(50, 32, 32);
      const material = new THREE.MeshPhongMaterial({
        shininess: 5,
        map: this.colorMap.texture
      });
      const ball = new THREE.Mesh(geometry, material);
      ball.rotation.set(0, -Math.PI, 0);
      scene.add(ball);
    }
  }

  new App(document.getElementById('app'));
</script>
</body>

</html>